.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Smoke::Syncer 3"
.TH Test::Smoke::Syncer 3 "2010-11-04" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Smoke::Syncer \- OO interface for syncing the perl source\-tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Smoke::Syncer;
\&
\&    my $type = \*(Aqrsync\*(Aq; # or \*(Aqsnapshot\*(Aq or \*(Aqcopy\*(Aq
\&    my $syncer = Test::Smoke::Syncer\->new( $type => %sync_config );
\&    my $patch_level = $syncer\->sync;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
At this moment we support three basic types of syncing the perl source-tree.
.IP "rsync" 4
.IX Item "rsync"
This method uses the \fBrsync\fR program with the \f(CW\*(C`\-\-delete\*(C'\fR option 
to get your perl source-tree up to date.
.IP "snapshot" 4
.IX Item "snapshot"
This method uses the \fBNet::FTP\fR or the \fB\s-1LWP\s0\fR module to get the 
latest snapshot. When the \fBserver\fR attribute starts with \fIhttp://\fR
the fetching is done by \f(CW\*(C`LWP::Simple::mirror()\*(C'\fR.
To emulate the \f(CW\*(C`rsync \-\-delete\*(C'\fR effect, the current source-tree
is removed.
.Sp
The snapshot tarball is handled by either \fBtar\fR/\fBgzip\fR or 
\&\fBArchive::Tar\fR/\fBCompress::Zlib\fR.
.IP "copy" 4
.IX Item "copy"
This method uses the \fBFile::Copy\fR module to copy an existing source-tree
from somewhere on the system (in case rsync doesn't work), this also 
removes the current source-tree first.
.IP "forest" 4
.IX Item "forest"
This method will sync the source-tree in one of the above basic methods.
After that, it will create an intermediate copy of the master directory 
as hardlinks and run the \fIregen_headers.pl\fR script. This should yield
an up-to-date source-tree. The intermadite directory is now copied as 
hardlinks to its final directory ({ddir}).
.Sp
This can be used to change the way \fBmake distclean\fR is run from 
\&\fImktest.pl\fR (removes all files that are not in the intermediate
directory, which may prove faster than traditional \fBmake distclean\fR).
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "Test::Smoke::Syncer\->new( $type, %sync_config )" 4
.el .IP "Test::Smoke::Syncer\->new( \f(CW$type\fR, \f(CW%sync_config\fR )" 4
.IX Item "Test::Smoke::Syncer->new( $type, %sync_config )"
[ Constructor | Public ]
.Sp
Initialise a new object and check all relevant arguments.
It returns an object of the appropriate \fBTest::Smoke::Syncer::*\fR class.
.ie n .IP "Test::Smoke::Syncer\->config( $key[, $value] )" 4
.el .IP "Test::Smoke::Syncer\->config( \f(CW$key\fR[, \f(CW$value\fR] )" 4
.IX Item "Test::Smoke::Syncer->config( $key[, $value] )"
[ Accessor | Public ]
.Sp
\&\f(CW\*(C`config()\*(C'\fR is an interface to the package lexical \f(CW%CONFIG\fR, 
which holds all the default values for the \f(CW\*(C`new()\*(C'\fR arguments.
.Sp
With the special key \fBall_defaults\fR this returns a reference
to a hash holding all the default values.
.ie n .IP "$syncer\->_clear_souce_tree( [$tree_dir] )" 4
.el .IP "\f(CW$syncer\fR\->_clear_souce_tree( [$tree_dir] )" 4
.IX Item "$syncer->_clear_souce_tree( [$tree_dir] )"
[ Method | private-ish ]
.Sp
\&\f(CW\*(C`_clear_source_tree()\*(C'\fR removes \fBall\fR files in the source-tree 
using \fB\f(BIFile::Path::rmtree()\fB\fR. (See File::Path for caveats.)
.Sp
If \f(CW$tree_dir\fR is not specified, \f(CW\*(C`$self\->{ddir}\*(C'\fR is used.
.ie n .IP "$syncer\->_relocate_tree( $source_dir )" 4
.el .IP "\f(CW$syncer\fR\->_relocate_tree( \f(CW$source_dir\fR )" 4
.IX Item "$syncer->_relocate_tree( $source_dir )"
[ Method | Private-ish ]
.Sp
\&\f(CW\*(C`_relocate_tree()\*(C'\fR uses \fB\f(BIFile::Copy::move()\fB\fR to move the source-tree 
from \f(CW$source_dir\fR to its destination (\f(CW\*(C`$self\->{ddir}\*(C'\fR).
.ie n .IP "$syncer\->check_dot_patch( )" 4
.el .IP "\f(CW$syncer\fR\->check_dot_patch( )" 4
.IX Item "$syncer->check_dot_patch( )"
[ Method | Public ]
.Sp
\&\f(CW\*(C`check_dot_patch()\*(C'\fR checks if there is a '.patch' file in the source-tree.
It will try to create one if it is not there (this is the case for snapshots).
.Sp
It returns the patchlevel found or \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "version_from_patchlevel_h( $ddir )" 4
.el .IP "version_from_patchlevel_h( \f(CW$ddir\fR )" 4
.IX Item "version_from_patchlevel_h( $ddir )"
\&\f(CW\*(C`version_from_patchlevel_h()\*(C'\fR returns a \*(L"dotted\*(R" version as derived 
from the \fIpatchlevel.h\fR file in the distribution.
.ie n .IP "$syncer\->clean_from_directory( $source_dir[, @leave_these] )" 4
.el .IP "\f(CW$syncer\fR\->clean_from_directory( \f(CW$source_dir\fR[, \f(CW@leave_these\fR] )" 4
.IX Item "$syncer->clean_from_directory( $source_dir[, @leave_these] )"
\&\f(CW\*(C`clean_from_directory()\*(C'\fR uses File::Find to get the contents of
\&\f(CW$source_dir\fR and compare these to {ddir} and remove all other files.
.Sp
The contents of \f(CW@leave_these\fR should be in \*(L"MANIFEST-format\*(R"
(See Test::Smoke::SourceTree).
.ie n .IP "$syncer\->pre_sync" 4
.el .IP "\f(CW$syncer\fR\->pre_sync" 4
.IX Item "$syncer->pre_sync"
\&\f(CW\*(C`pre_sync()\*(C'\fR should be called by the \f(CW\*(C`sync()\*(C'\fR methos to setup the
sync environment. Currently only useful on \fIOpenVMS\fR.
.ie n .IP "$syncer\->post_sync" 4
.el .IP "\f(CW$syncer\fR\->post_sync" 4
.IX Item "$syncer->post_sync"
\&\f(CW\*(C`post_sync()\*(C'\fR should be called by the \f(CW\*(C`sync()\*(C'\fR methos to unset the
sync environment. Currently only useful on \fIOpenVMS\fR.
.SH "Test::Smoke::Syncer::Rsync"
.IX Header "Test::Smoke::Syncer::Rsync"
This handles syncing with the \fBrsync\fR program. 
It should only be visible from the \*(L"parent-package\*(R" so no direct 
user-calls on this.
.ie n .IP "Test::Smoke::Syncer::Rsync\->new( %args )" 4
.el .IP "Test::Smoke::Syncer::Rsync\->new( \f(CW%args\fR )" 4
.IX Item "Test::Smoke::Syncer::Rsync->new( %args )"
This crates the new object. Keys for \f(CW%args\fR:
.Sp
.Vb 5
\&  * ddir:   destination directory ( ./perl\-current )
\&  * source: the rsync source ( ftp.linux.activestate.com::perl\-current )
\&  * opts:   the options for rsync ( \-az \-\-delete )
\&  * rsync:  the full path to the rsync program ( rsync )
\&  * v:      verbose
.Ve
.ie n .IP "$object\->sync( )" 4
.el .IP "\f(CW$object\fR\->sync( )" 4
.IX Item "$object->sync( )"
Do the actual sync using a call to the \fBrsync\fR program.
.Sp
\&\fBrsync\fR can also be used as a smart version of copy. If you 
use a local directory to rsync from, make sure the destination path
ends with a \fIpath separator\fR! (This does not seem to work for source
paths mounted via \s-1NFS\s0.)
.SH "Test::Smoke::Syncer::Snapshot"
.IX Header "Test::Smoke::Syncer::Snapshot"
This handles syncing from a snapshot with the \fBNet::FTP\fR module. 
It should only be visible from the \*(L"parent-package\*(R" so no direct 
user-calls on this.
.ie n .IP "Test::Smoke::Syncer::Snapshot\->new( %args )" 4
.el .IP "Test::Smoke::Syncer::Snapshot\->new( \f(CW%args\fR )" 4
.IX Item "Test::Smoke::Syncer::Snapshot->new( %args )"
This crates the new object. Keys for \f(CW%args\fR:
.Sp
.Vb 6
\&  * ddir:    destination directory ( ./perl\-current )
\&  * server:  the server to get the snapshot from ( public.activestate.com )
\&  * sdir:    server directory ( /pub/apc/perl\-current\-snap )
\&  * snapext: the extension used for snapdhots ( tgz )
\&  * tar:     howto untar ( Archive::Tar or \*(Aqgzip \-d \-c %s | tar x \-\*(Aq )
\&  * v:       verbose
.Ve
.ie n .IP "$syncer\->sync( )" 4
.el .IP "\f(CW$syncer\fR\->sync( )" 4
.IX Item "$syncer->sync( )"
Make a connection to the ftp server, change to the {sdir} directory.
Get the list of snapshots (\f(CW\*(C`/^perl@\ed+\e.tgz$/\*(C'\fR) and determin the 
highest patchlevel. Fetch this file.  Remove the current source-tree
and extract the snapshot.
.ie n .IP "$syncer\->_fetch_snapshot( )" 4
.el .IP "\f(CW$syncer\fR\->_fetch_snapshot( )" 4
.IX Item "$syncer->_fetch_snapshot( )"
\&\f(CW\*(C`_fetch_snapshot()\*(C'\fR checks to see if 
\&\f(CW\*(C`$self\->{server}\ =~\ m|^https?://| && $self\->{sfile}\*(C'\fR.
If so let \fBLWP::Simple\fR do the fetching else do the \s-1FTP\s0 thing.
.ie n .IP "$syncer\->_fetch_snapshot_HTTP( )" 4
.el .IP "\f(CW$syncer\fR\->_fetch_snapshot_HTTP( )" 4
.IX Item "$syncer->_fetch_snapshot_HTTP( )"
\&\f(CW\*(C`_fetch_snapshot_HTTP()\*(C'\fR simply invokes \f(CW\*(C`LWP::Simple::mirror()\*(C'\fR.
.ie n .IP "_\|_find_snap_name( $ftp, $snapext[, $verbose] )" 4
.el .IP "_\|_find_snap_name( \f(CW$ftp\fR, \f(CW$snapext\fR[, \f(CW$verbose\fR] )" 4
.IX Item "__find_snap_name( $ftp, $snapext[, $verbose] )"
[Not a method!]
.Sp
Get a list with all the \fBperl@\ed+\fR files, use an \s-1ST\s0 to sort these and
return the one with the highes number.
.ie n .IP "$syncer\->_extract_snapshot( )" 4
.el .IP "\f(CW$syncer\fR\->_extract_snapshot( )" 4
.IX Item "$syncer->_extract_snapshot( )"
\&\f(CW\*(C`_extract_snapshot()\*(C'\fR checks the \fBtar\fR attribute to find out how to 
extract the snapshot. This could be an external command or the 
\&\fBArchive::Tar\fR/\fBComperss::Zlib\fR modules.
.ie n .IP "$syncer\->_extract_with_Archive_Tar( )" 4
.el .IP "\f(CW$syncer\fR\->_extract_with_Archive_Tar( )" 4
.IX Item "$syncer->_extract_with_Archive_Tar( )"
\&\f(CW\*(C`_extract_with_Archive_Tar()\*(C'\fR uses the \fBArchive::Tar\fR and
\&\fBCompress::Zlib\fR modules to extract the snapshot. 
(This tested verry slow on my Linux box!)
.ie n .IP "$syncer\->_extract_with_external( )" 4
.el .IP "\f(CW$syncer\fR\->_extract_with_external( )" 4
.IX Item "$syncer->_extract_with_external( )"
\&\f(CW\*(C`_extract_with_external()\*(C'\fR uses \f(CW\*(C`$self\->{tar}\*(C'\fR as a \fIsprintf()\fR 
template to build a command. Yes that might be dangerous!
.ie n .IP "_\|_vms_untargz( $untargz, $tgzfile, $verbose )" 4
.el .IP "_\|_vms_untargz( \f(CW$untargz\fR, \f(CW$tgzfile\fR, \f(CW$verbose\fR )" 4
.IX Item "__vms_untargz( $untargz, $tgzfile, $verbose )"
Gunzip and extract the archive in \f(CW$tgzfile\fR using a small \s-1DCL\s0 script
.ie n .IP "$syncer\->patch_a_snapshot( $patch_number )" 4
.el .IP "\f(CW$syncer\fR\->patch_a_snapshot( \f(CW$patch_number\fR )" 4
.IX Item "$syncer->patch_a_snapshot( $patch_number )"
\&\f(CW\*(C`patch_a_snapshot()\*(C'\fR tries to fetch all the patches between
\&\f(CW$patch_number\fR and \f(CW\*(C`perl\-current\*(C'\fR and apply them. 
This requires a working \fBpatch\fR program.
.Sp
You should pass this extra information to
\&\f(CW\*(C`Test::Smoke::Syncer::Snapshot\->new()\*(C'\fR:
.Sp
.Vb 6
\&  * patchup:  should we do this? ( 0 )
\&  * pserver:  which FTP server? ( public.activestate.com )
\&  * pdir:     directory ( /pub/apc/perl\-current\-diffs )
\&  * unzip:    ( gzip ) [ Compress::Zlib ]
\&  * patchbin: ( patch )
\&  * cleanup:  remove patches after applied? ( 1 )
.Ve
.ie n .IP "$syncer\->_get_patches( [$patch_number] )" 4
.el .IP "\f(CW$syncer\fR\->_get_patches( [$patch_number] )" 4
.IX Item "$syncer->_get_patches( [$patch_number] )"
\&\f(CW\*(C`_get_patches()\*(C'\fR sets up the \s-1FTP\s0 connection and gets all patches 
beyond \f(CW$patch_number\fR. Remember that patch numbers  do not have to be 
consecutive.
.ie n .IP "$syncer\->_apply_patches( @patch_list )" 4
.el .IP "\f(CW$syncer\fR\->_apply_patches( \f(CW@patch_list\fR )" 4
.IX Item "$syncer->_apply_patches( @patch_list )"
\&\f(CW\*(C`_apply_patches()\*(C'\fR calls the \fBpatch\fR program to apply the patch
and updates \fB.patch\fR accordingly.
.Sp
\&\f(CW@patch_list\fR is a list of filenames of these patches.
.Sp
Checks the \fBunzip\fR attribute to find out how to unzip the patch and 
uses the \fBTest::Smoke::Patcher\fR module to apply the patch.
.ie n .IP "$syncer\->_read_patch( $file )" 4
.el .IP "\f(CW$syncer\fR\->_read_patch( \f(CW$file\fR )" 4
.IX Item "$syncer->_read_patch( $file )"
\&\f(CW\*(C`_read_patch()\*(C'\fR unzips the patch and returns the contents.
.ie n .IP "$syncer\->_fix_dot_patch( $new_level );" 4
.el .IP "\f(CW$syncer\fR\->_fix_dot_patch( \f(CW$new_level\fR );" 4
.IX Item "$syncer->_fix_dot_patch( $new_level );"
\&\f(CW\*(C`_fix_dot_patch()\*(C'\fR updates the \fB.patch\fR file with the new patch level.
.IP "_\|_get_directory_names( [$dir] )" 4
.IX Item "__get_directory_names( [$dir] )"
[This is \fBnot\fR a method]
.Sp
\&\f(CW\*(C`_\|_get_directory_names()\*(C'\fR retruns all directory names from 
\&\f(CW\*(C`$dir || cwd()\*(C'\fR. It does not look at symlinks (there should 
not be any in the perl source-tree).
.SH "Test::Smoke::Syncer::Copy"
.IX Header "Test::Smoke::Syncer::Copy"
This handles syncing with the \fBFile::Copy\fR module from a local 
directory. It uses the \fB\s-1MANIFEST\s0\fR file is the source directory
to determine which fiels to copy. The current source-tree removed 
before the actual copying.
.ie n .IP "Test::Smoke::Syncer::Copy\->new( %args )" 4
.el .IP "Test::Smoke::Syncer::Copy\->new( \f(CW%args\fR )" 4
.IX Item "Test::Smoke::Syncer::Copy->new( %args )"
This crates the new object. Keys for \f(CW%args\fR:
.Sp
.Vb 3
\&  * ddir:    destination directory ( ./perl\-current )
\&  * cdir:    directory to copy from ( undef )
\&  * v:       verbose
.Ve
.ie n .IP "$syncer\->sync( )" 4
.el .IP "\f(CW$syncer\fR\->sync( )" 4
.IX Item "$syncer->sync( )"
This uses \fBTest::Smoke::SourceTree\fR to do the actual copying.  After
that it will clean up the source-tree (from \fI\s-1MANIFEST\s0\fR, but ignoring
\&\fI\s-1MANIFEST\s0.SKIP\fR!).
.SH "Test::Smoke::Syncer::Hardlink"
.IX Header "Test::Smoke::Syncer::Hardlink"
This handles syncing by copying the source-tree from a local directory
using the \fBlink\fR function. This can be used as an alternative for
\&\fBmake distclean\fR.
.PP
Thanks to Nicholas Clark for donating this suggestion!
.ie n .IP "Test::Smoke::Syncer::Hardlink\->new( %args )" 4
.el .IP "Test::Smoke::Syncer::Hardlink\->new( \f(CW%args\fR )" 4
.IX Item "Test::Smoke::Syncer::Hardlink->new( %args )"
Keys for \f(CW%args\fR:
.Sp
.Vb 3
\&  * ddir: destination directory
\&  * hdir: source directory
\&  * v:    verbose
.Ve
.ie n .IP "$syncer\->sync( )" 4
.el .IP "\f(CW$syncer\fR\->sync( )" 4
.IX Item "$syncer->sync( )"
\&\f(CW\*(C`sync()\*(C'\fR uses the \fBFile::Find\fR module to make the hardlink forest in {ddir}.
.SH "Test::Smoke::Syncer::FTP"
.IX Header "Test::Smoke::Syncer::FTP"
This handles syncing by getting the source-tree from ActiveState's \s-1APC\s0
repository. It uses the \f(CW\*(C`Test::Smoke::FTPClient\*(C'\fR that implements a
mirror function.
.ie n .SS "Test::Smoke::Syncer::FTP\->new( %args )"
.el .SS "Test::Smoke::Syncer::FTP\->new( \f(CW%args\fP )"
.IX Subsection "Test::Smoke::Syncer::FTP->new( %args )"
Known args for this class:
.PP
.Vb 6
\&    * ftphost (public.activestate.com)
\&    * ftpusr  (anonymous)
\&    * ftppwd  (smokers@perl.org)
\&    * ftpsdir (/pub/apc/perl\-????)
\&    * ftpcdir (/pub/apc/perl\-????\-diffs)
\&    * ftype (undef|binary|ascii)
\&
\&    * ddir
\&    * v
.Ve
.ie n .SS "$syncer\->\fIsync()\fP"
.el .SS "\f(CW$syncer\fP\->\fIsync()\fP"
.IX Subsection "$syncer->sync()"
This does the actual syncing:
.PP
.Vb 2
\&    * Check {ftpcdir} for the latest changenumber
\&    * Mirror
.Ve
.ie n .SS "$syncer\->create_dat_patch"
.el .SS "\f(CW$syncer\fP\->create_dat_patch"
.IX Subsection "$syncer->create_dat_patch"
This needs to go to the *\-diffs directory on \s-1APC\s0 and find the patch
whith the highest number, that should be our current patchlevel.
.SH "Test::Smoke::Syncer::Forest"
.IX Header "Test::Smoke::Syncer::Forest"
This handles syncing by setting up a master directory that is in sync
with either a snapshot or the repository. Then it creates a copy of
this master directory as a hardlink forest and the \fBregenheaders.pl\fR
script is run (if found). Now the source-tree should be up to date
and ready to be copied as a hardlink forest again, to its final
destination.
.PP
Thanks to Nicholas Clark for donating this idea.
.ie n .IP "Test::Smoke::Syncer::Forest\->new( %args )" 4
.el .IP "Test::Smoke::Syncer::Forest\->new( \f(CW%args\fR )" 4
.IX Item "Test::Smoke::Syncer::Forest->new( %args )"
Keys for \f(CW%args\fR:
.Sp
.Vb 4
\&  * All keys from the other methods (depending on {fsync})
\&  * fsync: which master sync method is to be used
\&  * mdir:  master directory
\&  * fdir:  intermediate directory (first hardlink forest)
.Ve
.ie n .IP "$syncer\->sync( )" 4
.el .IP "\f(CW$syncer\fR\->sync( )" 4
.IX Item "$syncer->sync( )"
\&\f(CW\*(C`sync()\*(C'\fR starts with a \*(L"traditional\*(R" sync according to {ftype} in {mdir}.
It then creates a copy of {mdir} in {fdir} with hardlinks an tries to run
the \fBregen_headers.pl\fR script in {fdir}. This directory should now contain
an up to date (working) source-tree wich again using hardlinks is copied
to the destination directory {ddir}.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
rsync, gzip, tar, Archive::Tar, Compress::Zlib,
File::Copy, Test::Smoke::SourceTree
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
(c) 2002\-2003, All rights reserved.
.PP
.Vb 1
\&  * Abe Timmerman <abeltje@cpan.org>
.Ve
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
See:
.PP
.Vb 2
\&  * <http://www.perl.com/perl/misc/Artistic.html>,
\&  * <http://www.gnu.org/copyleft/gpl.html>
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
