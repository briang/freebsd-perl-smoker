.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Smoke::Util 3"
.TH Test::Smoke::Util 3 "2010-08-27" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Smoke::Util \- Take out some of the functions of the smoke suite.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
I've taken out some of the general stuff and put it here.
Now I can write some tests!
.ie n .IP "Configure_win32( $command[, $win32_maker[, @args]] )" 4
.el .IP "Configure_win32( \f(CW$command\fR[, \f(CW$win32_maker\fR[, \f(CW@args\fR]] )" 4
.IX Item "Configure_win32( $command[, $win32_maker[, @args]] )"
\&\f(CW\*(C`Configure_win32()\*(C'\fR alters the settings of the makefile for MSWin32.
.Sp
\&\f(CW$command\fR is in the form of './Configure \-des \-Dusedevel ...'
.Sp
\&\f(CW$win32_maker\fR should either be \f(CW\*(C`nmake\*(C'\fR or \f(CW\*(C`dmake\*(C'\fR, the default 
is \f(CW\*(C`nmake\*(C'\fR.
.Sp
\&\f(CW@args\fR is a list of \f(CW\*(C`option=value\*(C'\fR pairs that will (eventually)
be passed to Config.pm.
.Sp
\&\s-1PLEASE\s0 read \s-1README\s0.win32 and study the comments in the makefile.
.Sp
It supports these options:
.RS 4
.IP "\(bu" 4
\&\fB\-Duseperlio\fR
.Sp
set \s-1USE_PERLIO\s0 = define (default) [should be depricated]
.IP "\(bu" 4
\&\fB\-Dusethreads\fR
.Sp
set \s-1USE_ITHREADS\s0 = define (also sets \s-1USE_MULTI\s0 and \s-1USE_IMP_SYS\s0)
.IP "\(bu" 4
\&\fB\-Duseithreads\fR
.Sp
set \s-1USE_ITHREADS\s0 = define (also sets \s-1USE_MULTI\s0 and \s-1USE_IMP_SYS\s0)
.IP "\(bu" 4
\&\fB\-Dusemultiplicity\fR
.Sp
sets \s-1USE_MULTI\s0 = define (also sets \s-1USE_ITHREADS\s0 and \s-1USE_IMP_SYS\s0)
.IP "\(bu" 4
\&\fB\-Duseimpsys\fR
.Sp
sets \s-1USE_IMP_SYS\s0 = define (also sets \s-1USE_ITHREADS\s0 and \s-1USE_MULTI\s0)
.IP "\(bu" 4
\&\fB\-Dusemymalloc\fR
.Sp
set \s-1PERL_MALLOC\s0 = define
.IP "\(bu" 4
\&\fB\-Duselargefiles\fR
.Sp
set \s-1USE_LARGE_FILES\s0 = define
.IP "\(bu" 4
\&\fB\-Dbccold\fR
.Sp
set \s-1BCCOLD\s0 = define (this is for bcc32 <= 5.4)
.IP "\(bu" 4
\&\fB\-Dgcc_v3_2\fR
.Sp
set \s-1USE_GCC_V3_2\s0 = define (this is for gcc >= 3.2)
.IP "\(bu" 4
\&\fB\-DDEBUGGING\fR
.Sp
sets \s-1CFG\s0 = Debug
.IP "\(bu" 4
\&\fB\-DINST_DRV=...\fR
.Sp
sets \s-1INST_DRV\s0 to a new value (default is \*(L"c:\*(R")
.IP "\(bu" 4
\&\fB\-DINST_TOP=...\fR
.Sp
sets \s-1INST_DRV\s0 to a new value (default is \*(L"$(\s-1INST_DRV\s0)\eperl\*(R"), this is 
where perl will be installed when \f(CW\*(C`[nd]make install\*(C'\fR is run.
.IP "\(bu" 4
\&\fB\-DINST_VER=...\fR
.Sp
sets \s-1INST_VER\s0 to a new value (default is forced not set), this is also used
as part of the installation path to get a more unixy installation.
Without \f(CW\*(C`INST_VER\*(C'\fR and \f(CW\*(C`INST_ARCH\*(C'\fR you get an ActiveState like 
installation.
.IP "\(bu" 4
\&\fB\-DINST_ARCH=...\fR
.Sp
sets \s-1INST_ARCH\s0 to a new value (default is forced not set), this is also used
as part of the installation path to get a more unixy  installation.
Without \f(CW\*(C`INST_VER\*(C'\fR and \f(CW\*(C`INST_ARCH\*(C'\fR you get an ActiveState like 
installation.
.IP "\(bu" 4
\&\fB\-DCCHOME=...\fR
.Sp
Set the base directory for the C compiler.
\&\fB$(\s-1CCHOME\s0)\ebin\fR still needs to be in the path!
.IP "\(bu" 4
\&\fB\-DIS_WIN95\fR
.Sp
sets \s-1IS_WIN95\s0 to 'define' to indicate this is Win9[58]
.IP "\(bu" 4
\&\fB\-DCRYPT_SRC=...\fR
.Sp
The file to use as source for \fIdes_fcrypt()\fR
.IP "\(bu" 4
\&\fB\-DCRYPT_LIB=...\fR
.Sp
The library to use for \fIdes_fcrypt()\fR
.IP "\(bu" 4
\&\fB\-Dcf_email=...\fR
.Sp
Set the cf_email option (Config.pm)
.IP "\(bu" 4
\&\fB\-Accflags=...\fR
.Sp
Adds the option to \s-1BUILDOPT\s0. This is implemented differently for 
\&\fBnmake\fR and \fBdmake\fR.
Returns the name of the outputfile.
.RE
.RS 4
.RE
.ie n .IP "set_vms_rooted_logical( $logical, $dir )" 4
.el .IP "set_vms_rooted_logical( \f(CW$logical\fR, \f(CW$dir\fR )" 4
.IX Item "set_vms_rooted_logical( $logical, $dir )"
This will set a \s-1VMS\s0 rooted logical like:
.Sp
.Vb 1
\&    define/translation=concealed $logical $dir
.Ve
.IP "get_cfg_filename( )" 4
.IX Item "get_cfg_filename( )"
\&\f(CW\*(C`get_cfg_filename()\*(C'\fR tries to find a \fBcfg file\fR and returns it.
.ie n .IP "grepccmsg( $cc, $logfile, $verbose )" 4
.el .IP "grepccmsg( \f(CW$cc\fR, \f(CW$logfile\fR, \f(CW$verbose\fR )" 4
.IX Item "grepccmsg( $cc, $logfile, $verbose )"
This is a port of Jarkko Hietaniemi's grepccerr script.
.ie n .IP "get_local_patches( $ddir )" 4
.el .IP "get_local_patches( \f(CW$ddir\fR )" 4
.IX Item "get_local_patches( $ddir )"
\&\f(CW\*(C`get_local_patches()\*(C'\fR reads \fIpatchlevel.h\fR to scan for the locally
applied patches array.
.ie n .IP "set_local_patch( $ddir, @descr )" 4
.el .IP "set_local_patch( \f(CW$ddir\fR, \f(CW@descr\fR )" 4
.IX Item "set_local_patch( $ddir, @descr )"
Copy the code from \fIpatchlevel.h\fR. Older (pre 5.8.1) perls do not
have it and it doesn't work on MSWin32.
.ie n .IP "get_config( $filename )" 4
.el .IP "get_config( \f(CW$filename\fR )" 4
.IX Item "get_config( $filename )"
Read and parse the configuration from file, or return the default
config.
.IP "get_patch( [$ddir] )" 4
.IX Item "get_patch( [$ddir] )"
Try to find the patchlevel, look for \fB.patch\fR or try to get it from
\&\fBpatchlevel.h\fR as a fallback.
.ie n .IP "version_from_patchlevel_h( $ddir )" 4
.el .IP "version_from_patchlevel_h( \f(CW$ddir\fR )" 4
.IX Item "version_from_patchlevel_h( $ddir )"
\&\f(CW\*(C`version_from_patchlevel_h()\*(C'\fR returns a \*(L"dotted\*(R" version as derived 
from the \fIpatchlevel.h\fR file in the distribution.
.ie n .IP "get_ncpu( $osname )" 4
.el .IP "get_ncpu( \f(CW$osname\fR )" 4
.IX Item "get_ncpu( $osname )"
\&\f(CW\*(C`get_ncpu()\*(C'\fR returns the number of available (online/active/enabled) CPUs.
.Sp
It does this by using some operating system specific trick (usually
by running some external command and parsing the output).
.Sp
If it cannot recognize your operating system an empty string is returned.
If it can recognize it but the external command failed, \f(CW"? cpus"\fR 
is returned.
.Sp
In the first case (where we really have no idea how to proceed),
also a warning (\f(CW\*(C`get_ncpu: unknown operating system\*(C'\fR) is sent to \s-1STDERR\s0.
.IP "\fB\s-1WARNINGS\s0\fR" 4
.IX Item "WARNINGS"
If you get the warning \f(CW\*(C`get_ncpu: unknown operating system\*(C'\fR, you will
need to help us\*(-- how does one tell the number of available CPUs in
your operating system?  Sometimes there are several different ways:
please try to find the fastest one, and a one that does not require
superuser (administrator) rights.
.Sp
Thanks to Jarkko Hietaniemi for donating this!
.ie n .IP "get_smoked_Config( $dir, @keys )" 4
.el .IP "get_smoked_Config( \f(CW$dir\fR, \f(CW@keys\fR )" 4
.IX Item "get_smoked_Config( $dir, @keys )"
\&\f(CW\*(C`get_smoked_Config()\*(C'\fR returns a hash (a listified hash) with the
specified keys. It will try to find \fIlib/Config.pm\fR to get those
values, if that cannot be found (make error?) we can try \fIconfig.sh\fR
which is used to build \fIlib/Config.pm\fR. 
If \fIconfig.sh\fR is not there (./Configure error?) we try to get some
fallback information from \f(CW\*(C`POSIX::uname()\*(C'\fR and \fIpatchlevel.h\fR.
.ie n .IP "parse_report_Config( $report )" 4
.el .IP "parse_report_Config( \f(CW$report\fR )" 4
.IX Item "parse_report_Config( $report )"
\&\f(CW\*(C`parse_report_Config()\*(C'\fR returns a list attributes from a smoke report.
.Sp
.Vb 2
\&    my( $version, $plevel, $os, $osvers, $archname, $summary ) = 
\&        parse_report_Config( $rpt );
.Ve
.ie n .IP "get_regen_headers( $ddir )" 4
.el .IP "get_regen_headers( \f(CW$ddir\fR )" 4
.IX Item "get_regen_headers( $ddir )"
\&\f(CW\*(C`get_regen_headers()\*(C'\fR looks in \f(CW$ddir\fR to find either 
\&\fIregen_headers.pl\fR or \fIregen.pl\fR (change 18851).
.Sp
Returns undef if not found or a string like \f(CW\*(C`$^X "$regen_headers_pl"\*(C'\fR
.ie n .IP "run_regen_headers( $ddir, $verbose );" 4
.el .IP "run_regen_headers( \f(CW$ddir\fR, \f(CW$verbose\fR );" 4
.IX Item "run_regen_headers( $ddir, $verbose );"
\&\f(CW\*(C`run_regen_headers()\*(C'\fR gets its executable from \f(CW\*(C`get_regen_headers()\*(C'\fR
and opens a pipe from it. \fIwarn()\fRs on error.
.ie n .IP "whereis( $prog )" 4
.el .IP "whereis( \f(CW$prog\fR )" 4
.IX Item "whereis( $prog )"
Try to find an executable instance of \f(CW$prog\fR in \f(CW$ENV\fR{\s-1PATH\s0}.
.Sp
Rreturns a full file-path (with extension) to it.
.ie n .IP "vms_whereis( $prog )" 4
.el .IP "vms_whereis( \f(CW$prog\fR )" 4
.IX Item "vms_whereis( $prog )"
First look in the \s-1SYMBOLS\s0 to see if \f(CW$prog\fR is there.
Next look in the KFE-table \f(CW\*(C`INSTALL LIST\*(C'\fR if it is there.
As a last resort we can scan \f(CW\*(C`DCL$PATH\*(C'\fR like we do on *nix/Win32
.ie n .IP "clean_filename( $fname )" 4
.el .IP "clean_filename( \f(CW$fname\fR )" 4
.IX Item "clean_filename( $fname )"
\&\f(CW\*(C`clean_filename()\*(C'\fR basically returns a \fIvmsify()\fR type of filename for
\&\s-1VMS\s0, and returns an upcase filename for case-ignorant filesystems.
.ie n .IP "calc_timeout( $killtime[, $from] )" 4
.el .IP "calc_timeout( \f(CW$killtime\fR[, \f(CW$from\fR] )" 4
.IX Item "calc_timeout( $killtime[, $from] )"
\&\f(CW\*(C`calc_timeout()\*(C'\fR calculates the timeout in seconds. 
\&\f(CW$killtime\fR can be one of two formats:
.RS 4
.IP "\fB+hh:mm\fR" 8
.IX Item "+hh:mm"
This format represents a duration and is the easy format as we only need
to translate that to seconds.
.IP "\fBhh:mm\fR" 8
.IX Item "hh:mm"
This format represents a clock time (localtime).  Calculate minutes
from midnight for both \f(CW$killtime\fR and \f(CW\*(C`localtime($from)\*(C'\fR, and get
the difference. If \f(CW$from\fR is omitted, \f(CW\*(C`time()\*(C'\fR is used.
.Sp
If \f(CW$killtime\fR is the actual time, the timeout will be 24 hours!
.RE
.RS 4
.RE
.ie n .IP "time_in_hhmm( $diff )" 4
.el .IP "time_in_hhmm( \f(CW$diff\fR )" 4
.IX Item "time_in_hhmm( $diff )"
Create a string telling elapsed time in days, hours, minutes, seconds
from the number of seconds.
.ie n .IP "do_pod2man( %pod2usage_options )" 4
.el .IP "do_pod2man( \f(CW%pod2usage_options\fR )" 4
.IX Item "do_pod2man( %pod2usage_options )"
If Pod::Usage is there then call its \f(CW\*(C`pod2usage()\*(C'\fR.
In the other case, print the general message passed with the \f(CW\*(C`myusage\*(C'\fR key.
.ie n .IP "skip_config( $config )" 4
.el .IP "skip_config( \f(CW$config\fR )" 4
.IX Item "skip_config( $config )"
Returns true if this config should be skipped.
\&\f(CW$config\fR should be a \fBTest::Smoke::BuildCFG::Config\fR object.
.ie n .IP "skip_filter( $line )" 4
.el .IP "skip_filter( \f(CW$line\fR )" 4
.IX Item "skip_filter( $line )"
\&\f(CW\*(C`skip_filter()\*(C'\fR returns true if the filter rules apply to \f(CW$line\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
(c) 2001\-2003, All rights reserved.
.PP
.Vb 4
\&  * H. Merijn Brand <h.m.brand@hccnet.nl>
\&  * Nicholas Clark <nick@unfortu.net>
\&  * Jarkko Hietaniemi <jhi@iki.fi>
\&  * Abe Timmerman <abeltje@cpan.org>
.Ve
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
See:
.PP
.Vb 2
\&  * <http://www.perl.com/perl/misc/Artistic.html>,
\&  * <http://www.gnu.org/copyleft/gpl.html>
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
